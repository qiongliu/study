### 函数表达式
1.函数声明，它的一个重要特征就是函数声明提升。

2.函数表达式，会创建一个函数并将它赋值给一个变量，这种情况下创建的函数叫做匿名函数。

3.能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。

4.递归函数是在一个函数通过名字调用自身的情况下构成的。arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。

5.闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

6.后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建局部函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用局部函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对
象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中 compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

7.在匿名函数从 createComparisonFunction()中被返回后，它的作用域链被初始化为包含
createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在
createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()
函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换
句话说，当 createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活
动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会
被销毁。

8.闭包所保存的是整个变量对象，而不是某个特殊的变量。

9.匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。

10.JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不
见（不过，它会执行后续声明中的变量初始化）。

